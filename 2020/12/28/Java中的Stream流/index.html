<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
  <script type="text/javascript">
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'UA-xxxxxx-xx');
  </script>
  

  <!-- Baidu Tongji -->
  
  <script type="text/javascript">
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  

  <!-- Baidu Push -->
  
  <script>
    (function() {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>
  

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc" />
  <meta name="baidu-site-verification" content="PpzM9WxOJU" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="It&#39;s an IT blog..." />
  <meta name="keyword" content="lancer,lancer1126,livemylife,IT  blog,Blog" />
  <link rel="shortcut icon" href="/img/avatar/roguerabbit.jpg" />

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>
  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css" />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/beantech.min.css" />

  <!-- Pygments Highlight CSS -->
  
<link rel="stylesheet" href="../../../../css/highlight.css">
<link rel="stylesheet" href="../../../../css/widget.css">
<link rel="stylesheet" href="../../../../css/rocket.css">
<link rel="stylesheet" href="../../../../css/signature.css">
<link rel="stylesheet" href="../../../../css/catalog.css">
<link rel="stylesheet" href="../../../../css/livemylife.css">


  
  <!-- wave start -->
  <link rel="stylesheet" href="/css/wave.css" />
  <!-- wave end -->
  

  
  <!-- top start (article top hot config) -->
  <link rel="stylesheet" href="/css/top.css" />
  <!-- top end -->
  

  
  <!-- ThemeColor start -->
  <link rel="stylesheet" href="/css/scroll.css" />
  <!-- ThemeColor end -->
  

  
  <!-- viewer start (Picture preview) -->
  <link rel="stylesheet" href="/css/viewer.min.css" />
  <!-- viewer end -->
  

  
  <!-- Search start -->
  <link rel="stylesheet" href="/css/search.css" />
  <!-- Search end -->
  

  
  <!-- ThemeColor start -->
  <link rel="stylesheet" href="/css/themecolor.css" />
  <!-- ThemeColor end -->
  

  

  
  <!-- gitalk start -->
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
  <link rel="stylesheet" href="/css/gitalk.css" />
  <!-- gitalk end -->
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
    href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://yoursite-url/2020/12/28/Java中的Stream流/">
  <title>
    
    Java中的Stream流 - Relax
    
  </title>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->

<body ontouchstart="" class="body--home">
	<!-- ThemeColor -->
	
	<!-- ThemeColor -->
<!-- <div class="toggle" onclick="document.body.classList.toggle('body--dark')">Switch Color</div> -->

<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons bright-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>

	

	<!-- Gitter -->
	
	<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

	

	<!-- Navigation (contains search)-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">老王的博客</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">Home</a>
          </li>

          

          
          

          
          <li>
            <a href="/about/">About</a>
          </li>
          
          

          
          <li>
            <a href="/categories/">Categories</a>
          </li>
          
          

          
          <li>
            <a href="/tags/">Tags</a>
          </li>
          
          

          
          <li>
            <a href="/archive/">Archives</a>
          </li>
          
          

          
          <li><a class="popup-trigger" title="Search"><span class="search-icon"></span>Search</a></li>
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>


<script>
  // Drop Bootstarp low-performance Navbar
  // Use customize navbar with high-quality material design animation
  // in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


	<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    header.intro-header {
       /*post*/
        background-image: url('/img/header_img/java8-features.png');
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/lance.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#Java" title="Java">Java</a>
              
            </div>
            <h1>Java中的Stream流</h1>
            <h2 class="subheading">Java笔记</h2>
            <span class="meta">
              Posted by lancer1126 on
              2020-12-28
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">12</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">3k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- 不蒜子统计 start -->
            <span class="meta">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            <!-- WordCount end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



	<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
	<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <blockquote>
<p>Stream流在早在Java8中就已推出，但一直保持着听说过，没用过的状态。现在根据掘金的文章<br><a href="https://juejin.cn/post/6844903830254010381" target="_blank" rel="noopener"> 一文带你玩转 Java8 Stream 流，从此操作集合 So Easy</a><br>对Java中的Stream流做一个系统的学习。  </p>
</blockquote>
<h2 id="Stream流是怎么工作的"><a href="#Stream流是怎么工作的" class="headerlink" title="Stream流是怎么工作的"></a>Stream流是怎么工作的</h2><p>流包含着一系列元素的集合，我们可以对其做不同类型的操作，使用这些元素来执行计算，用代码表示就是  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b2"</span>, <span class="string">"c3"</span>);</span><br><span class="line">myList</span><br><span class="line">    .stream()                           <span class="comment">// (1)创建一个流</span></span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"a"</span>))     <span class="comment">// (2)使用Lambda语法筛选出所有以a开头的元素</span></span><br><span class="line">    .map(String::toUpperCase)           <span class="comment">// (3)转换成大写</span></span><br><span class="line">    .sorted()                           <span class="comment">// (4)进行排序</span></span><br><span class="line">    .forEach(System.out::println);      <span class="comment">// (5)for循环打印</span></span><br></pre></td></tr></table></figure>

<p>在上文的代码中，(2)(3)(4)属于<strong>中间操作</strong>，而(5)属于<strong>终端操作</strong>。  </p>
<ul>
<li>中间操作：中间操作会再次返回一个流，因此可以链接多个中间操作，不用加分号可以直接进行相连。</li>
<li>终端操作：对流操作的一个结束动作，一般返回一个void或者一个非流的结果，foreach便是一个终结操作。  </li>
</ul>
<p>流类似于流水线式操作并且大部分操作都支持lambda表达式作为参数。</p>
<h2 id="不同类型的Stream流"><a href="#不同类型的Stream流" class="headerlink" title="不同类型的Stream流"></a>不同类型的Stream流</h2><p>可以从各种数据源中创建Stream流，其中以Collection集合最为常见，如List和Set等。<br>流又分顺序流与并行流，先从顺序流开始：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>,<span class="string">"a2"</span>,<span class="string">"a3"</span>)  </span><br><span class="line">                .stream()                           <span class="comment">// 创建流       </span></span><br><span class="line">                .findFirst()                        <span class="comment">// 找到第一个元素</span></span><br><span class="line">                .ifPresent(System.out::println);    <span class="comment">// 若是存在，则输出</span></span><br></pre></td></tr></table></figure>
<p>使用<code>asList()</code>方法创建一个集合，这时不用再刻意创建一个新的集合来接收，在原有集合的基础上可以直接使用<code>stream()</code>方法来获取创建一个流。也可以使用<code>Stream.of()</code>来从一堆对象中直接创建Stream流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"a1"</span>,<span class="string">"a2"</span>,<span class="string">"c3"</span>)</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>除了常规对象流之外，Java8还附带了一些流用于处理原始数据类型的int，long和double，在其中，IntStreams.range()方法还可以取代常规的fori循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">                .forEach(System.out::println);  <span class="comment">// 相当于for (int i = 1, i &lt; 4; i++) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>若是有将常规对象转换为原始类型流的需求，可以使用<code>mapToInt()</code>,<code>mapToLong()</code>和<code>mapToDouble()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"a1"</span>,<span class="string">"a2"</span>,<span class="string">"a3"</span>)</span><br><span class="line">                .map(s -&gt; s.substring(<span class="number">1</span>))           <span class="comment">// 对每个字符串元素从下标1开始截取</span></span><br><span class="line">                .mapToInt(Integer::parseInt)        <span class="comment">// 转为Int类型</span></span><br><span class="line">                .max()                              <span class="comment">// 取最大值</span></span><br><span class="line">                .ifPresent(System.out::println);    <span class="comment">// 若存在则输出</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>若是要将原始数据类型转换为对象流，可以使用<code>mapToObj()</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">                .mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">                .forEach(System.out::println);              </span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure>

<h2 id="Stream流的处理顺序"><a href="#Stream流的处理顺序" class="headerlink" title="Stream流的处理顺序"></a>Stream流的处理顺序</h2><p>中间操作有个重要的特性——<strong>延迟性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"c1"</span>,<span class="string">"c3"</span>,<span class="string">"b4"</span>,<span class="string">"g5"</span>)</span><br><span class="line">                .filter(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"filter: "</span>+ s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码并不会依次打印流中所有的元素，因为当且仅当<strong>存在终端操作时</strong>，中间操作才会执行。<br>对上述代码进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"c1"</span>,<span class="string">"c3"</span>,<span class="string">"b4"</span>,<span class="string">"g5"</span>)</span><br><span class="line">        .filter(s -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"filter: "</span>+ s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span>+ s));</span><br><span class="line"><span class="comment">// filter: c1</span></span><br><span class="line"><span class="comment">// forEach: c1</span></span><br><span class="line"><span class="comment">// filter: c3</span></span><br><span class="line"><span class="comment">// forEach: c3</span></span><br><span class="line"><span class="comment">// filter: b4</span></span><br><span class="line"><span class="comment">// forEach: b4</span></span><br><span class="line"><span class="comment">// filter: g5</span></span><br><span class="line"><span class="comment">// forEach: g5</span></span><br><span class="line">```  </span><br><span class="line">以上的输出显示，流并不是在filter中所有元素打印，再在forEach中打印所有元素，而是随着链条垂直移动，当Stream处理第一个`<span class="string">"c1"</span>`元素时，会顺着流的顺序执行完所有操作，才会继续执行第二个元素`<span class="string">"c3"</span>`。  </span><br><span class="line">  </span><br><span class="line">这主要是出于性能方面的考虑，这样设计可以减少对每个元素的实际操作数，查看以下代码：</span><br><span class="line">```java</span><br><span class="line">Stream.of(<span class="string">"e6"</span>,<span class="string">"a1"</span>,<span class="string">"a2"</span>,<span class="string">"b3"</span>,<span class="string">"c4"</span>,<span class="string">"d5"</span>)</span><br><span class="line">                .map(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"map: "</span>+ s);</span><br><span class="line">                    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">                &#125;)</span><br><span class="line">                .anyMatch(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"anyMatch: "</span>+ s);</span><br><span class="line">                    <span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">// map: e6</span></span><br><span class="line"><span class="comment">// anyMatch: E6</span></span><br><span class="line"><span class="comment">// map: a1</span></span><br><span class="line"><span class="comment">// anyMatch: A1</span></span><br></pre></td></tr></table></figure>
<p>代码中anyMatch()表示一旦遇到以<code>&#39;A&#39;</code>为前缀的元素就停止循环，从<code>&quot;e6&quot;</code>开始垂直执行一遍，循环到<code>&quot;a1&quot;</code>，返回为true，结束代码。<br>因为数据流的链式调用时垂直执行的，map在这里只需要执行两次，若是水平执行，map会先将所有元素都遍历一遍，降低了效率。</p>
<h2 id="中间操作的顺序设计"><a href="#中间操作的顺序设计" class="headerlink" title="中间操作的顺序设计"></a>中间操作的顺序设计</h2><p>以下代码由中间操作map和filter，终端操作forEach祖成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>,<span class="string">"a2"</span>,<span class="string">"b1"</span>,<span class="string">"b3"</span>,<span class="string">"c"</span>)</span><br><span class="line">                .map(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"map: "</span>+s);</span><br><span class="line">                    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">                &#125;)</span><br><span class="line">                .filter(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"filter: "</span>+s);</span><br><span class="line">                    <span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span>+ s));</span><br><span class="line"><span class="comment">// map: d2</span></span><br><span class="line"><span class="comment">// filter: D2</span></span><br><span class="line"><span class="comment">// map: a2</span></span><br><span class="line"><span class="comment">// filter: A2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// map: b1</span></span><br><span class="line"><span class="comment">// filter: B1</span></span><br><span class="line"><span class="comment">// map: b3</span></span><br><span class="line"><span class="comment">// filter: B3</span></span><br><span class="line"><span class="comment">// map: c</span></span><br><span class="line"><span class="comment">// filter: C</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，map和filter都会先执行5次，forEach只会调用一次，因为只有”a2”满足条件。<br>若改变map与filter的顺序，可以大大减少执行的次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>,<span class="string">"a2"</span>,<span class="string">"b1"</span>,<span class="string">"b3"</span>,<span class="string">"c"</span>)</span><br><span class="line">                .filter(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"filter: "</span>+s);</span><br><span class="line">                    <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .map(s -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"map: "</span>+s);</span><br><span class="line">                    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">                &#125;)</span><br><span class="line">                .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span>+ s));</span><br><span class="line"><span class="comment">// filter: d2</span></span><br><span class="line"><span class="comment">// filter: a2</span></span><br><span class="line"><span class="comment">// map: a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// filter: b1</span></span><br><span class="line"><span class="comment">// filter: b3</span></span><br><span class="line"><span class="comment">// filter: c</span></span><br></pre></td></tr></table></figure>
<p>filter()筛选出以’a’开头的元素，若不符合，则不会进行后续操作，改变了Stream()流方法的执行顺序，大大减少了不必要的代码执行。  </p>
<h2 id="数据流复用问题"><a href="#数据流复用问题" class="headerlink" title="数据流复用问题"></a>数据流复用问题</h2><p>Stream流不能被复用，一旦执行了任何终端操作，流就会被关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"d2"</span>, <span class="string">"d3"</span>, <span class="string">"b1"</span>, <span class="string">"c4"</span>)</span><br><span class="line">                .filter(s -&gt; s.startsWith(<span class="string">"d"</span>));</span><br><span class="line">stream.anyMatch(s -&gt; <span class="keyword">true</span>);     <span class="comment">// 可以执行</span></span><br><span class="line">stream.noneMatch(s -&gt; <span class="keyword">true</span>);    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>为了克服这个限制，可以为我们想要执行的每个终端操作创建一个新的流链，例如，可以使用Supplier来包装流，通过get()方法来构建一个新的Strean流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="string">"d2"</span>, <span class="string">"d3"</span>, <span class="string">"b1"</span>, <span class="string">"c4"</span>)</span><br><span class="line">                .filter(s -&gt; s.startsWith(<span class="string">"d"</span>));</span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="keyword">true</span>);</span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>通过构造一个新的流，可以避开流不能被复用的限制。</p>
<h2 id="Stream流高级操作"><a href="#Stream流高级操作" class="headerlink" title="Stream流高级操作"></a>Stream流高级操作</h2><p>Stream不仅有filter，map等中间操作，还支持一些更复杂的例如collect，flatMap和reduce操作。<br>以下代码均使用List&lt; Person &gt;进行演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个 Person 集合</span></span><br><span class="line">List&lt;Person&gt; persons = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Max"</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Peter"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Pamela"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"David"</span>, <span class="number">12</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a><strong>Collect</strong></h3><p><strong>collect</strong>将流中的元素转变成另一个不同的对象，例如一个List、Set或Map。collect接受入参为Collector（收集器），有四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。  </p>
<p>但这些大多数情况下不需要自己去实现收集器，Java通过Collectors类内置了各种常用的收集器，可以直接拿来用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; p1 = persons.stream()                      <span class="comment">// 创建一个流</span></span><br><span class="line">                .filter(p -&gt; p.name.startsWith(<span class="string">"P"</span>))    <span class="comment">// 筛选出以"P"开头的元素</span></span><br><span class="line">                .collect(Collectors.toList());          <span class="comment">// 创建一个新的List</span></span><br><span class="line">System.out.println(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Peter, Pamela]</span></span><br></pre></td></tr></table></figure>
<p>上述代码使用Collectors中的toList()方法从原有的List中根据过滤方法创建一个新的List，若是Set对象，则使用Collectors。toSet()方法。  </p>
<ul>
<li><p>Collectors.groupingBy()可以对流对象进行分组。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personByAge = persons.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(p -&gt; p.age));        <span class="comment">// 根据age进行分组并创建一个新的对象</span></span><br><span class="line"></span><br><span class="line">personByAge.forEach((age,p) -&gt;</span><br><span class="line">        System.out.format(<span class="string">"age %s: %s\n"</span>,age, p)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// age 18: [Max]</span></span><br><span class="line"><span class="comment">// age 23: [Peter, Pamela]</span></span><br><span class="line"><span class="comment">// age 12: [David]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算所有人平均年龄  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Double averageAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.averagingInt(p -&gt; p.age)); <span class="comment">// 聚合出平均年龄</span></span><br><span class="line"></span><br><span class="line">System.out.println(averageAge);     <span class="comment">// 19.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算最小年龄、最大年龄、平均年龄、总和以及总数量。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics ageSummary =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.summarizingInt(p -&gt; p.age)); <span class="comment">// 生成摘要统计</span></span><br><span class="line"></span><br><span class="line">System.out.println(ageSummary);</span><br><span class="line"><span class="comment">// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有人名连接成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String phrase = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.age &gt;= <span class="number">18</span>) <span class="comment">// 过滤出年龄大于等于18的</span></span><br><span class="line">    .map(p -&gt; p.name) <span class="comment">// 提取名字</span></span><br><span class="line">    .collect(Collectors.joining(<span class="string">" and "</span>, <span class="string">"In Germany "</span>, <span class="string">" are of legal age."</span>)); <span class="comment">// 以 In Germany 开头，and 连接各元素，再以 are of legal age. 结束</span></span><br><span class="line"></span><br><span class="line">System.out.println(phrase);</span><br><span class="line"><span class="comment">// In Germany Max and Peter and Pamela are of legal age.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对于如何将流转换为 Map集合，必须指定 Map 的键和值。这里需要注意，Map 的键必须是唯一的，否则会抛出IllegalStateException 异常。  </p>
<p>可以选择传递一个合并函数作为额外的参数来避免发生这个异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        p -&gt; p.age,</span><br><span class="line">        p -&gt; p.name,</span><br><span class="line">        (name1, name2) -&gt; name1 + <span class="string">";"</span> + name2)); <span class="comment">// 对于同样 key 的，将值拼接</span></span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// &#123;18=Max, 23=Peter;Pamela, 12=David&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a><strong>FlatMap</strong></h3><p>Map只能将对象映射到单个对象，若想将一个对象转换为多个其他对象或者根本不想做转换操作时，可以使用flatMap。<br>FlatMap能够将流的每个元素转换为其他对象的类，因此，每个对象可以被转换为零至多个其他对象，并以流的方式返回，这些流的内容会放入flatMap返回的流中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体例子后续补充</span></span><br></pre></td></tr></table></figure>

<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a><strong>Reduce</strong></h3><p>规约操作可以将流的所有元素组合成一个结果，Java8支持三种不同的reduce方法。</p>
<ol>
<li><p>将流中的元素规约成流中的一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)</span><br><span class="line">    .ifPresent(System.out::println);    <span class="comment">// Pamela</span></span><br></pre></td></tr></table></figure>
<p>以上代码筛选出年龄最大的那个人。<br>reduce方法接受BinaryOperator积累函数。该函数实际上是两个操作数类型相同的BiFunction。BiFunction功能和Function一样，但是它接受两个参数。示例代码中，我们比较两个人的年龄，来返回年龄较大的人。  </p>
</li>
<li><p>reduce方法接受标识值和BinaryOperator累加器。此方法可用于构造一个新的 Person，其中包含来自流中所有其他人的聚合名称和年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person result =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce(<span class="keyword">new</span> Person(<span class="string">""</span>, <span class="number">0</span>), (p1, p2) -&gt; &#123;</span><br><span class="line">            p1.age += p2.age;</span><br><span class="line">            p1.name += p2.name;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"name=%s; age=%s"</span>, result.name, result.age);</span><br><span class="line"><span class="comment">// name=MaxPeterPamelaDavid; age=76</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce方法接受三个参数：标识值，BiFunction累加器和类型的组合器函数BinaryOperator。由于初始值的类型不一定为Person，可以使用这个归约函数来计算所有人的年龄总和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line"></span><br><span class="line">System.out.println(ageSum);  <span class="comment">// 76</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>流是可以并行执行的，当流中存在大量元素时，可以显著提升性能。  </p>
<p>并行流底层使用的ForkJoinPool, 它由ForkJoinPool.commonPool()方法提供。底层线程池的大小最多为五个 - 具体取决于 CPU 可用核心数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool commonPool = ForkJoinPool.commonPool();</span><br><span class="line">System.out.println(commonPool.getParallelism());    <span class="comment">// 3</span></span><br><span class="line">```  </span><br><span class="line">集合支持parallelStream()方法来创建元素的并行流。或者你可以在已存在的数据流上调用中间方法parallel()，将串行流转换为并行流，这也是可以的。</span><br><span class="line">```java</span><br><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"filter: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"map: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">"forEach: %s [%s]\n"</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  b1 [main]</span></span><br><span class="line"><span class="comment">// filter:  a2 [ForkJoinPool.commonPool-worker-1]</span></span><br><span class="line"><span class="comment">// map:     a2 [ForkJoinPool.commonPool-worker-1]</span></span><br><span class="line"><span class="comment">// filter:  c2 [ForkJoinPool.commonPool-worker-3]</span></span><br><span class="line"><span class="comment">// map:     c2 [ForkJoinPool.commonPool-worker-3]</span></span><br><span class="line"><span class="comment">// filter:  c1 [ForkJoinPool.commonPool-worker-2]</span></span><br><span class="line"><span class="comment">// map:     c1 [ForkJoinPool.commonPool-worker-2]</span></span><br><span class="line"><span class="comment">// forEach: C2 [ForkJoinPool.commonPool-worker-3]</span></span><br><span class="line"><span class="comment">// forEach: A2 [ForkJoinPool.commonPool-worker-1]</span></span><br><span class="line"><span class="comment">// map:     b1 [main]</span></span><br><span class="line"><span class="comment">// forEach: B1 [main]</span></span><br><span class="line"><span class="comment">// filter:  a1 [ForkJoinPool.commonPool-worker-3]</span></span><br><span class="line"><span class="comment">// map:     a1 [ForkJoinPool.commonPool-worker-3]</span></span><br><span class="line"><span class="comment">// forEach: A1 [ForkJoinPool.commonPool-worker-3]</span></span><br><span class="line"><span class="comment">// forEach: C1 [ForkJoinPool.commonPool-worker-2]</span></span><br></pre></td></tr></table></figure>
<p>并行流使用了所有的ForkJoinPool中的可用线程来执行流式操作。在持续的运行中，输出结果可能有所不同，因为所使用的特定线程是非特定的。  </p>
<p>并行流对含有大量元素的数据流提升性能极大。但是也需要记住并行流的一些操作，例如reduce和collect操作，需要额外的计算（如组合操作），这在串行执行时是并不需要。</p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          
          <li class="next">
            <a href="/2020/12/25/Vue学习小记（一）/" data-toggle="tooltip" data-placement="top" title="Vue学习小记（一）">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <div class="tip">
          <p>
            If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
          </p>
        </div>
        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=Java中的Stream流&body=Hi,I found this website and thought you might like it http://yoursite-url/2020/12/28/Java中的Stream流/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

<!-- gitalk start -->
<!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

<div id="gitalk-container"></div>

<!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
<script src="/js/comment/gitalk.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: '',
    id: 'Mon Dec 28 2020 00:00:00 GMT+0800', // Ensure uniqueness and length less than 50
    distractionFreeMode: false, // Facebook-like distraction free mode
    perPage: 10 ,
    pagerDirection: 'last',
    createIssueManually: false ,
    language: 'en'
  });
  gitalk.render('gitalk-container');

  var gtFolded = () => {
    setTimeout(function() {
      let markdownBody = document.getElementsByClassName("markdown-body");
      let list = Array.from(markdownBody);
      list.forEach(item => {
        if (item.clientHeight > 250) {
          item.classList.add('gt-comment-body-folded');
          item.style.maxHeight = '250px';
          item.title = 'Click to Expand';
          item.onclick = function() {
            item.classList.remove('gt-comment-body-folded');
            item.style.maxHeight = '';
            item.title = '';
            item.onclick = null;
          };
        }
      })
    }, 800);
  }
</script>

<!-- gitalk end -->



<!-- 2. gitment comment -->



<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Stream流是怎么工作的"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Stream流是怎么工作的</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#不同类型的Stream流"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">不同类型的Stream流</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Stream流的处理顺序"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Stream流的处理顺序</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#中间操作的顺序设计"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">中间操作的顺序设计</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数据流复用问题"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">数据流复用问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Stream流高级操作"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">Stream流高级操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Collect"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">Collect</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FlatMap"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">FlatMap</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Reduce"><span class="toc-nav-number">6.3.</span> <span class="toc-nav-text">Reduce</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#并行流"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">并行流</span></a></li></ol>
        
        </div>
      </aside>
    


      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#Java" title="Java">Java</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>FRIENDS</h5>
        <ul class="list-inline">

          
          <li>
            <a href="" target="_blank">No friend,for now</a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



	<!-- Footer (contains ThemeColor、viewer) -->
	<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/lancer1126">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          lancer1126
          2020
          <br>
          Theme by
          <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a href="https://v-vincen.life/" target="_blank" rel="noopener">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>

<!-- jQuery -->
<script type="text/javascript" src="/js/jquery.min.js"></script>
<!-- <script type="text/javascript" src="/js/jquery.js"></script> -->
<!-- <script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script> -->

<!-- Bootstrap Core JavaScript -->
<script type="text/javascript" src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script type="text/javascript" src="/js/hux-blog.min.js"></script>

<!-- catalog -->
<script type="text/javascript" async="true" src="/js/catalog.js?v=1.0.0"></script>

<!-- totop(rocket) -->
<script type="text/javascript" async="true" src="/js/totop.js?v=1.0.0"></script>

<!-- Busuanzi JavaScript -->
<script type="text/javascript" async="true" src="/js/busuanzi.pure.mini.js"></script>


  <!-- Scroll start -->
  <script type="text/javascript" src="/js/scroll.js"></script>
  <!-- Scroll end -->



  <!-- ThemeColor start -->
  <script type="text/javascript" src="/js/themecolor.js"></script>
  <!-- ThemeColor end -->





  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  <script type="text/javascript" src="/js/viewer/viewer.min.js"></script>
  <script type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){ hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if($('#tag_cloud').length !== 0){ async("http://yoursite-url/js/jquery.tagcloud.js",function(){ $.fn.tagcloud.defaults = { //size: {start: 1, end: 1, unit: 'em'}, color: {start:
'#bbbbee', end: '#0085a1'}, }; $('#tag_cloud a').tagcloud(); }) } </script> -->


	<!-- Search -->
	
	<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  <script src="/js/ziploader.js"></script>
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;

            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


	

	<!-- Image to hack wechat -->
	<!-- <img src="http://yoursite-url/img/icon_wechat.png" width="0" height="0" /> -->
	<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
